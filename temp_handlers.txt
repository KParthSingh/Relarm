    private fun handlePauseCountdownLoop() {
        Log.d("ChainService", "handlePauseCountdownLoop() - Stopping countdown loop for battery saving")
        // Cancel countdown job to stop polling every second
        countdownJob?.cancel()
        countdownJob = null
        Log.d("ChainService", "Countdown loop paused, AlarmManager alarm will still trigger")
    }
    
    private fun handleResumeCountdownLoop() {
        Log.d("ChainService", "handleResumeCountdownLoop() - Resuming countdown loop")
        
        // Recalculate remaining time from stored endTime
        val storedEndTime = ChainManager(this).getEndTime()
        if (storedEndTime == 0L) {
            Log.w("ChainService", "No stored endTime, cannot resume countdown loop")
            return
        }
        
        // Update local endTime
        endTime = storedEndTime
        
        // Recalculate and update ChainManager with current remaining time
        updateChainManager()
        Log.d("ChainService", "Remaining time recalculated: ${getRemainingTime()}s")
        
        // Restart countdown loop
        countdownJob?.cancel()
        countdownJob = serviceScope.launch {
            while (isActive && System.currentTimeMillis() < endTime) {
                delay(1000)
                if (!isActive) break
                
                // ALWAYS update ChainManager for UI
                updateChainManager()
                
                // Don't show notification (hide counter is ON)
                // Notification is already hidden, no need to check
            }
            
            if (isActive) {
                // Countdown finished, trigger the alarm
                Log.d("ChainService", "Countdown finished, triggering alarm")
                triggerAlarm()
            }
        }
        Log.d("ChainService", "Countdown loop resumed")
    }
